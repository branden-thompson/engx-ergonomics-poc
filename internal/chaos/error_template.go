package chaos

import (
	"fmt"
	"strings"
	"time"
)

// ErrorTemplate represents a standardized error message template
type ErrorTemplate struct {
	// Core error information
	BottomLineMessage    string
	Summary             string

	// Recovery actions
	FirstAction         string
	SecondAction        string
	OnCallCrew          string

	// Context and debugging
	AdditionalContext   string
	StackTrace          string

	// Chaos-specific information
	IsChaosGenerated    bool
	ChaosScenarioType   string
	ChaosLevel          string

	// Metadata
	Timestamp           time.Time
	Operation           string
	StepName            string
}

// ErrorSeverity defines error severity levels
type ErrorSeverity int

const (
	SeverityInfo ErrorSeverity = iota
	SeverityWarning
	SeverityCritical
	SeverityFatal
)

// String returns the string representation of severity
func (s ErrorSeverity) String() string {
	switch s {
	case SeverityInfo:
		return "INFO"
	case SeverityWarning:
		return "WARNING"
	case SeverityCritical:
		return "CRITICAL FAILURE"
	case SeverityFatal:
		return "FATAL ERROR"
	default:
		return "UNKNOWN"
	}
}

// FormatError formats the error using the standardized template (80-char width)
func (et *ErrorTemplate) FormatError(severity ErrorSeverity) string {
	var builder strings.Builder
	const maxWidth = 80

	// Header with severity - format: ---- ERROR ---------------------------------------------- {FAILURE TYPE} ----
	headerPrefix := "---- ERROR ---------------------------------------------- "
	headerSuffix := " ----"
	availableSpace := maxWidth - len(headerPrefix) - len(headerSuffix)

	severityText := severity.String()
	if len(severityText) > availableSpace {
		severityText = severityText[:availableSpace-3] + "..."
	}

	headerText := fmt.Sprintf("%s%s%s", headerPrefix, severityText, headerSuffix)
	builder.WriteString(headerText)
	builder.WriteString("\n\n")

	// Bottom line error message (wrap if needed)
	errorMsg := fmt.Sprintf("  x %s", et.BottomLineMessage)
	builder.WriteString(wrapText(errorMsg, maxWidth-4, "    "))
	builder.WriteString("\n")

	// Recovery section
	builder.WriteString("  Let's get you back on track:\n")

	// Format actions with proper wrapping (80-char aware)
	builder.WriteString(formatAction("   ├ Try:", et.FirstAction, maxWidth))
	builder.WriteString(formatAction("   ├ If that doesn't work:", et.SecondAction, maxWidth))
	builder.WriteString(formatAction("   └ Still stuck? Contact:", et.OnCallCrew, maxWidth))
	builder.WriteString("\n")

	// Summary section
	builder.WriteString("  Summary:\n")
	wrappedSummary := wrapText(et.Summary, maxWidth-6, "   └ ")
	builder.WriteString(wrappedSummary)
	builder.WriteString("\n")

	// Additional Context section
	if et.AdditionalContext != "" {
		builder.WriteString("  Additional Context:\n")
		wrappedContext := wrapText(et.AdditionalContext, maxWidth-6, "   └ ")
		builder.WriteString(wrappedContext)
		builder.WriteString("\n")
	}

	// Stack trace if available
	if et.StackTrace != "" {
		builder.WriteString(et.StackTrace)
		builder.WriteString("\n")
	}

	// Add empty line before footer for breathability
	builder.WriteString("\n")

	// Footer - format: ---- Error generated by CHAOS MARINE (Scout Level) --------------------------
	var footerText string
	if et.IsChaosGenerated {
		footerText = fmt.Sprintf("---- Error generated by CHAOS MARINE (%s level) ", et.ChaosLevel)
		// Pad with dashes to exactly 80 characters
		dashesNeeded := maxWidth - len(footerText)
		footerText = footerText + strings.Repeat("-", dashesNeeded)
	} else {
		footerText = "---- This is a REAL system error - please report if unexpected "
		// Pad with dashes to exactly 80 characters
		dashesNeeded := maxWidth - len(footerText)
		footerText = footerText + strings.Repeat("-", dashesNeeded)
	}

	// Ensure exactly 80 characters
	if len(footerText) > maxWidth {
		footerText = footerText[:maxWidth]
	}
	builder.WriteString(footerText)

	return builder.String()
}

// formatAction formats an action line with proper 80-char wrapping
func formatAction(label, action string, maxWidth int) string {
	line := fmt.Sprintf("%s %s", label, action)
	if len(line) <= maxWidth {
		return line + "\n"
	}

	// If too long, wrap it
	firstLine := label
	continuationPrefix := "   │ "

	// Calculate remaining space on first line
	remainingSpace := maxWidth - len(firstLine) - 1 // -1 for space

	if len(action) <= remainingSpace {
		return fmt.Sprintf("%s %s\n", firstLine, action)
	}

	// Split action into words and wrap
	words := strings.Fields(action)
	var result strings.Builder
	result.WriteString(firstLine)
	result.WriteString(" ")

	currentLine := firstLine + " "
	for i, word := range words {
		if len(currentLine)+len(word)+1 <= maxWidth {
			if i > 0 {
				result.WriteString(" ")
				currentLine += " "
			}
			result.WriteString(word)
			currentLine += word
		} else {
			// Start new line
			result.WriteString("\n")
			result.WriteString(continuationPrefix)
			result.WriteString(word)
			currentLine = continuationPrefix + word
		}
	}
	result.WriteString("\n")
	return result.String()
}

// wrapText wraps text to specified width with prefix
func wrapText(text string, width int, prefix string) string {
	if len(text) <= width {
		return prefix + text + "\n"
	}

	var builder strings.Builder
	words := strings.Fields(text)
	currentLine := prefix
	prefixLen := len(prefix)

	for _, word := range words {
		// Check if adding this word would exceed width
		if len(currentLine)+len(word)+1 > width+prefixLen {
			// Write current line and start new one
			builder.WriteString(currentLine)
			builder.WriteString("\n")
			currentLine = prefix + word
		} else {
			if len(currentLine) > prefixLen {
				currentLine += " "
			}
			currentLine += word
		}
	}

	// Write final line
	if len(currentLine) > prefixLen {
		builder.WriteString(currentLine)
		builder.WriteString("\n")
	}

	return builder.String()
}

// NewChaosErrorTemplate creates a new error template for chaos-generated errors
func NewChaosErrorTemplate(scenarioType, operation, stepName string, level AggressivenessLevel) *ErrorTemplate {
	return &ErrorTemplate{
		IsChaosGenerated:  true,
		ChaosScenarioType: scenarioType,
		ChaosLevel:        level.String(),
		Operation:         operation,
		StepName:          stepName,
		Timestamp:         time.Now(),
		OnCallCrew:        "DevOps Team", // Default, could be configurable
	}
}

// NewRealErrorTemplate creates a new error template for actual system errors
func NewRealErrorTemplate(operation, stepName string) *ErrorTemplate {
	return &ErrorTemplate{
		IsChaosGenerated: false,
		Operation:        operation,
		StepName:         stepName,
		Timestamp:        time.Now(),
		OnCallCrew:       "DevOps Team", // Default, could be configurable
	}
}

// Predefined error templates for common scenarios
var DefaultErrorTemplates = map[string]*ErrorTemplate{
	"network_failure": {
		BottomLineMessage: "Network connection failed during dependency download",
		FirstAction:       "npm cache clean --force && npm install",
		SecondAction:      "Check your internet connection and try again",
		Summary:          "The npm install command failed because it couldn't reach the package registry. This commonly happens due to network connectivity issues, corporate firewall restrictions, or temporary registry outages.",
		AdditionalContext: "This error occurred during the 'Installing dependencies' step. The npm registry may be experiencing issues, or your network configuration might be blocking the connection. If you're behind a corporate firewall, you may need to configure npm proxy settings.",
		OnCallCrew:       "DevOps Team",
	},

	"permission_denied": {
		BottomLineMessage: "Permission denied when creating project files",
		FirstAction:       "sudo chown -R $USER:$USER . && chmod 755 .",
		SecondAction:      "Try running the command from a different directory",
		Summary:          "The file system operation failed due to insufficient permissions. This typically happens when the current directory has restrictive permissions or is owned by a different user.",
		AdditionalContext: "This error occurred during the 'Generating project structure' step. The system was unable to create the necessary files and directories for your project. Check that you have write permissions to the current directory and that there are no file system restrictions in place.",
		OnCallCrew:       "DevOps Team",
	},

	"resource_exhausted": {
		BottomLineMessage: "Insufficient disk space or memory to complete operation",
		FirstAction:       "df -h . && free -h",
		SecondAction:      "Clear some disk space and try again",
		Summary:          "The operation failed because the system ran out of available resources (disk space or memory). This can happen during large dependency installations or when the system is under heavy load.",
		AdditionalContext: "This error occurred during project creation. Check available disk space with 'df -h' and available memory with 'free -h'. You may need to free up space or close other applications before retrying.",
		OnCallCrew:       "DevOps Team",
	},

	"dependency_conflict": {
		BottomLineMessage: "Package dependency conflict detected",
		FirstAction:       "rm -rf node_modules package-lock.json && npm install",
		SecondAction:      "npm install --legacy-peer-deps",
		Summary:          "The package manager detected conflicting dependency versions that cannot be automatically resolved. This often happens when different packages require incompatible versions of the same dependency.",
		AdditionalContext: "This error occurred during dependency resolution. Modern package managers try to find compatible versions automatically, but sometimes manual intervention is required. The suggested commands will clear the dependency cache and retry with different resolution strategies.",
		OnCallCrew:       "Frontend Team",
	},
}